"""
Test loading Fluidics program.
- Verifies if program keys are present in the MUX configurations, raises execption if not.

Sheppard 08/04 - Initialization
"""
from ElveFlow_fluidics import FlowControl
import pandas as pd
import time
import sys

# Define the path to your Excel file
program_path = '/home/steven/Downloads/test_fluidics_run.xlsx'

class MissingMuxKey(Exception):
    """Custom exception for invalid MUX values."""
    def __init__(self, value, mux_name):
        super().__init__(f"Fluidics program source '{value}' is not a valid key in {mux_name} configuration.")
        self.value = value
        self.mux_name = mux_name

def read_fluidics_program(program_path: str = None,
                          flow_controller=None,
                          verbose: bool = False):
    """
    Load fluidics program saved as work book (.xlsx)
    Each 'sheet' or 'tab' corresponds to a round.

    Args:
        program_path (str): Path to the fluidics .xlsx program file. Defaults to None.
        flow_controller (Class):
        verbose (bool, optional): Print progress statements. Defaults to False
    """
    try:
        # Load the Excel file
        excel_data = pd.ExcelFile(program_path)
    except Exception as e:
        print(f"Error loading program workbook, path:{program_path}\n", f"Exception: {e}")
        sys.exit()

    # Function to check if key is in either mux1 or mux2
    def check_mux_key(key, mux1_config, mux2_config):
        if key is not None and key not in mux1_config and key not in mux2_config:
            raise MissingMuxKey(key, 'mux1 or mux2')

    # Create a list to store each sheet as a DataFrame
    program_list = []

    # Iterate through each sheet name and read it into a DataFrame, then append to the list
    for sheet_name in excel_data.sheet_names:
        df = pd.read_excel(program_path, sheet_name=sheet_name, engine='openpyxl')

        df = df[["round", "type", "pause", "source", "prime_buffer", "volume", "rate"]]
        df.dropna(axis=0, how='any', inplace=True)
        df["round"] = df["round"].astype(int)
        df["type"] = df["type"].astype(str)
        df["source"] = df["source"].astype(str).replace('none', None)
        df["prime_buffer"] = df["prime_buffer"].astype(str).replace('none', None)
        df["volume"] = df["volume"].astype(float)
        df["rate"] = df["rate"].astype(float)
        df["pause"] = df["pause"].astype(float)

        # Verify program source and prime_buffer exist in the ElveFlow MUX config keys
        try:
            # Check 'source' column
            df["source"].apply(lambda x: check_mux_key(x,
                                                       flow_controller.config["mux1"],
                                                       flow_controller.config["mux2"]))

            # Check 'prime_buffer' column
            df["prime_buffer"].apply(lambda x: check_mux_key(x,
                                                             flow_controller.config["mux1"],
                                                             flow_controller.config["mux2"]))

        except MissingMuxKey as e:
            print(f"{e}\n", f"Source key not found for round {df['round'].iloc[0]}")
            sys.exit()

        program_list.append(df)

    if verbose:
        # print the first few entries of each round
        for i, sheet in enumerate(program_list):
            print(f"{excel_data.sheet_names[i]}")
            print(sheet.head())

    return program_list


def run_fluidic_program(df_program,
                        flow_controller):

    """
    Run fluidics program for a given round. Requires data structure generated by ASU fluidics program generator (define_fluidics_program.ipynb)
    :param r_idx: int
        fluidics round to execute, expected as human notation,
        not numpy's (first round is 1, not 0)
    :param df_program: dataframe
        dataframe containing entire fluidics program
    :param mvp_controller: HamiltonMVP
        handle to initialized chain of Hamilton MVP valves
    :param pump_controller: APump
        handle to initialized pump

    :return True: boolean
        TO DO: need to work this into try/except statements to catch any pump errors
    """

    # select current round
    # print(time_stamp(), ': Executing iterative round '+str(r_idx)+'.')
    fluidics_success = False
    for index, row in df_program.iterrows():
        # Extract program functions
        type_name = str(row["type"]).strip()
        source_name = str(row['source']).strip()
        prime_buffer = str(row['buffer_source']).strip()
        flow_rate = str(row['rate']).strip()
        volume = str(row['volume']).strip()
        pause = str(row['pause']).strip()

        if type_name=="flush":
            # Run system flush with given source/volume/rate
            print(f"Fluidics starting flush:\n",
                  f"   source:{source_name}, volume:{volume:.2f}uL, rate:{flow_rate:.2f}uL/min")
            try:
                fluidics_success = flow_controller.run_flush(source=source_name,
                                                             rate=flow_rate,
                                                             volume=volume,
                                                             wait=pause,
                                                             verbose=False)
            except Exception as e:
                print(f"Exception occurred in Fluidics flush: {e}")

            if fluidics_success:
                print("Fluidics flush success!")

        elif type_name=="pid":
            # Run a flow contronlled loop to pump specfified volume
            print(f"Fluidics starting controlled flow:\n",
                  f"   source:{source_name}, volume:{volume:.2f}uL, rate:{flow_rate:.2f}uL/min")
            try:
                fluidics_success = flow_controller.run_pid_loop(source=source_name,
                                                                rate=flow_rate,
                                                                volume=volume,
                                                                wait=pause,
                                                                verbose=False)
            except Exception as e:
                print(f"Exception occurred in Fluidics flow: {e}")

        elif type_name=="prime":
            # Run a the prime program to push a volume of fluid to the sample chamber
            print(f"Fluidics starting priming to sample chamber:\n",
                  f"   source:{source_name}, prime_buffer:{prime_buffer} volume:{volume:.2f}uL, rate:{flow_rate:.2f}uL/min")
            if prime_buffer=="None":
                prime_buffer=="SSC"

            try:
                fluidics_success = flow_controller.run_prime_source(source=source_name,
                                                                    prime_buffer=prime_buffer,
                                                                    rate=flow_rate,
                                                                    volume=volume,
                                                                    wait=pause,
                                                                    verbose=False)
            except Exception as e:
                print(f"Exception occurred in Fluidics flow: {e}")

        # elif type_name=="refresh":
        #     # Pause program until the user confirms fluid refresh is complete
        #     refresh_approved = False
        #     while not(refresh_approved):
        #         refresh_approved = easygui.ynbox('Refresh complete?', 'Title', ('Yes', 'No'))

        #     # Run system prime and flush to prepare lines and remove air bubbles
        #     flow_controller.run_system_prime()

        else:
            print(f"No valid fluidics program selected index={index}); moving to next line")

    return True


# Connect to fluidics device
flow_controller = FlowControl()
flow_controller.startup()

# Read the fluidics program to get a list of round dataframes
program_list = read_fluidics_program(program_path, flow_controller, verbose=True)


# Iterate through rounds, running the fluidics and waiting for imaging.
for round_df in program_list:
    run_fluidic_program(round_df, flow_controller)

    # take a 2 hour time pause to simulate the imaging
    time.sleep(60*60*2)

# shutdown Fluidics connection
flow_controller.shutdown()